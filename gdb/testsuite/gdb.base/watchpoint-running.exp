# This testcase is part of GDB, the GNU debugger.

# Copyright 2023-2024 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This test verifies that you can set a watchpoint that watches global
# memory, when the selected thread is running.

set allow_hw_watchpoint_tests_p [allow_hw_watchpoint_tests]

standard_testfile

if [build_executable "failed to prepare" $testfile $srcfile {debug}] {
    return -1
}

# The time the usleep in the test-case waits, in miliseconds.
set usleep 100

# STOP_MODE is either "all-stop" or "non-stop".  HW is true if we are
# testing hardware watchpoints, and false if we're testing software
# watchpoints.

proc test {stop_mode hw} {

    save_vars { ::GDBFLAGS } {
	if { $stop_mode == "non-stop" } {
	    append ::GDBFLAGS " -ex \"set non-stop on\""
	} elseif {[target_info gdb_protocol] == "remote"
		  || [target_info gdb_protocol]== "extended-remote"} {
	    # Communicating with the target while the inferior is
	    # running depends on target running in non-stop mode.
	    # Force it on for remote targets, until this is the
	    # default.
	    append ::GDBFLAGS " -ex \"maint set target-non-stop on\""
	}
	clean_restart $::binfile
    }

    gdb_test_no_output "set can-use-hw-watchpoints $hw"

    if {![runto_main]} {
	return
    }

    delete_breakpoints

    set val1 ""
    gdb_test_multiple "print global_var" "global_var once" {
	-re -wrap " = ($::decimal)" {
	    set val1 $expect_out(1,string)
	    pass "$gdb_test_name"
	}
    }

    # Continue the program in the background.
    set test "continue&"
    gdb_test_multiple "continue&" $test {
	-re "Continuing\\.\r\n$::gdb_prompt " {
	    pass $test
	}
    }

    set test "global_var twice"
    set test2 "values are different"
    set iterations 0
    while { 1 } {
	set val2 ""
	gdb_test_multiple "print global_var" $test {
	    -re -wrap " = ($::decimal)" {
		set val2 $expect_out(1,string)
	    }
	}

	if { $val2 == "" } {
	    return
	}

	if { $val1 != $val2 } {
	    break
	}

	incr iterations
	if { $iterations == [expr $::timeout * 1000 / $::usleep] } {
	    pass $test
	    fail "$test2 (timeout)"
	    return
	}

	# Wait for the same period as the usleep in the test-case.
	after $::usleep
    }
    pass $test
    pass $test2

    set sw_wp_str "Watchpoint"
    set hw_wp_str "Hardware watchpoint"

    # Now set a watchpoint, while the inferior is running.  Since
    # we're watching a global, and we can read global memory while the
    # target is running, this should be able to work.
    set have_hw_watchpoint 0
    set have_sw_watchpoint 0
    set test "watch global_var"
    gdb_test_multiple $test "" {
	-re -wrap "$hw_wp_str $::decimal: global_var" {
	    set wp_str $hw_wp_str
	    set have_hw_watchpoint 1
	}
	-re -wrap "$sw_wp_str $::decimal: global_var" {
	    set have_sw_watchpoint 1
	    set wp_str $sw_wp_str
	}
    }

    if { ! $have_hw_watchpoint && ! $have_sw_watchpoint } {
	# Watchpoint cannot hit, bail out.
	return
    }

    if { $hw && $have_sw_watchpoint } {
	# This can happen.  Even if the target allows hw watchpoint, it's not
	# guaranteed that it can set a hw watchpoint while the target is
	# running.
	pass "$test (requested hw wp, got sw wp)"

	# The sw scenario is already explictly tested, no need to do
	# it twice.
	return
    }

    if { !$hw && $have_hw_watchpoint } {
	# Should not happen.
	fail "$test (requested sw wp, got hw wp)"

	# The hw scenario is already explictly tested, no need to do
	# it twice.
	return
    }

    pass $test

    # Check that the watchpoint triggers.

    set test "watchpoint hit"
    if {!$hw} {
	# This doesn't currently work with software watchpoints.
	# GDB should transparently temporarily pause the inferior,
	# to force it to single step, but it doesn't, so the
	# thread continues running free.
	kfail gdb/31833 $test
	return
    }
    set re [multi_line \
		"$wp_str $::decimal: global_var" \
		"" \
		"Old value = $::decimal" \
		"New value = $::decimal"]
    gdb_test_multiple "" "watchpoint hit" {
	-re $re {
	    pass $gdb_test_name
	}
    }
}

foreach hw {0 1} {
    if {$hw && !$allow_hw_watchpoint_tests_p} {
	continue
    }
    foreach stop_mode {all-stop non-stop} {
	set wp_type [expr ($hw)?"hardware":"software"]
	with_test_prefix "$stop_mode: $wp_type" {
	    test $stop_mode $hw
	}
    }
}
