# Copyright 2008-2023 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

# This file is part of the GDB testsuite.  It tests reverse stepping.
# Lots of code borrowed from "step-test.exp".

# The reverse finish command should return from a function and stop on
# the first instruction of the source line where the function call is made.
# Specifically, the behavior should match doing a reverse next from the
# first instruction in the function.  GDB should only take one reverse step
# or next statement to reach the previous source code line.

# This testcase verifies the reverse-finish command stops at the first
# instruction in the source code line where the function was called.  There
# are two scenarios that must be checked:
#   1) gdb is at the entry point instruction for the function
#   2) gdb is in the body of the function.

# This test verifies the fix for gdb bugzilla:
#   https://sourceware.org/bugzilla/show_bug.cgi?id=29927

if ![supports_reverse] {
    return
}

standard_testfile

if { [prepare_for_testing "failed to prepare" $testfile $srcfile] } {
    return -1
}

runto_main
set target_remote [gdb_is_target_remote]

if [supports_process_record] {
    # Activate process record/replay.
    gdb_test_no_output "record" "turn on process record for test1"
}


### TEST 1: reverse finish from the entry point instruction in
### function1.

# Set breakpoint at call to function1 in main.
set bp_FUNCTION [gdb_get_line_number "CALL FUNCTION" $srcfile]
gdb_breakpoint $srcfile:$bp_FUNCTION temporary

# Continue to break point at function1 call in main.
gdb_continue_to_breakpoint \
    "stopped at function1 entry point instruction to stepi into function" \
    ".*$srcfile:$bp_FUNCTION\r\n.*"

# stepi until we see "{" indicating we entered function1
repeat_cmd_until "stepi" "CALL FUNCTION" "{" "stepi into function1 call"

gdb_test "reverse-finish" ".*function1 \\(a, b\\);   // CALL FUNCTION.*" \
    "reverse-finish function1 "

# Check to make sure we stopped at the first instruction in the source code
# line.  It should only take one reverse next command to get to the previous
# source line.   If GDB stops at the last instruction in the source code line
# it will take two reverse next instructions to get to the previous source
# line.
gdb_test "reverse-next" ".*b = 5;.*" "reverse next at b = 5, call from function"

# Clear the recorded log.
gdb_test "record stop"  "Process record is stopped.*" \
    "turn off process record for test1"
gdb_test_no_output "record" "turn on process record for test2"


### TEST 2: reverse finish from the body of function1.

# Set breakpoint at call to function1 in main.
gdb_breakpoint $srcfile:$bp_FUNCTION temporary

# Continue to break point at function1 call in main.
gdb_continue_to_breakpoint \
    "at function1 entry point instruction to step to body of function" \
    ".*$srcfile:$bp_FUNCTION\r\n.*"

# do a step instruction to get to the body of the function
gdb_test "step" ".*int ret = 0;.*" "step test 1"

gdb_test "reverse-finish" ".*function1 \\(a, b\\);   // CALL FUNCTION.*" \
    "reverse-finish function1 call from function body"

# Check to make sure we stopped at the first instruction in the source code
# line.  It should only take one reverse next command to get to the previous
# source line.
gdb_test "reverse-next" ".*b = 5;.*" \
    "reverse next at b = 5, from function body"
